diff --git a/generator/generator.go b/generator/generator.go
index a1c7e5e..e191dc3 100644
--- a/generator/generator.go
+++ b/generator/generator.go
@@ -109,7 +109,7 @@ func writeGoCodeSingleFile(w io.Writer, goCode *ygen.GeneratedGoCode) error {
 }
 
 // writeIfNotEmpty writes the string s to b if it has a non-zero length.
-func writeIfNotEmpty(b io.StringWriter, s string) {
+func writeIfNotEmpty(b *strings.Builder, s string) {
 	if len(s) != 0 {
 		b.WriteString(s)
 	}
diff --git a/genutil/common.go b/genutil/common.go
index 6b9f251..7caee4a 100644
--- a/genutil/common.go
+++ b/genutil/common.go
@@ -18,9 +18,9 @@ package genutil
 
 import (
 	"fmt"
-	"io"
 	"sort"
-
+	"strings"
+	
 	"github.com/openconfig/goyang/pkg/yang"
 	"github.com/openconfig/ygot/util"
 	"github.com/openconfig/ygot/ygot"
@@ -42,7 +42,7 @@ const (
 )
 
 // WriteIfNotEmpty writes the string s to b if it has a non-zero length.
-func WriteIfNotEmpty(b io.StringWriter, s string) {
+func WriteIfNotEmpty(b *strings.Builder, s string) {
 	if len(s) != 0 {
 		b.WriteString(s)
 	}
diff --git a/util/debug.go b/util/debug.go
index 225468e..5c5ea23 100644
--- a/util/debug.go
+++ b/util/debug.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -53,6 +56,14 @@ func DbgPrint(v ...interface{}) {
 	fmt.Println(globalIndent + out)
 }
 
+func IsDebugLibraryEnabled () bool {
+	return debugLibrary
+}
+
+func IsDebugSchemaEnabled () bool {
+	return debugSchema
+}
+
 // DbgSchema prints v if the package global variable debugSchema is set.
 // v has the same format as Printf.
 func DbgSchema(v ...interface{}) {
@@ -177,6 +188,9 @@ func SchemaTypeStr(schema *yang.Entry) string {
 
 // YangTypeToDebugString returns a debug string representation of a YangType.
 func YangTypeToDebugString(yt *yang.YangType) string {
+	if !debugLibrary {
+		return ""
+	}
 	out := fmt.Sprintf("(TypeKind: %s", yang.TypeKindToName[yt.Kind])
 	if len(yt.Pattern) != 0 {
 		out += fmt.Sprintf(", Pattern: %s", strings.Join(yt.Pattern, " or "))
diff --git a/util/path.go b/util/path.go
index c5709dc..decfc08 100644
--- a/util/path.go
+++ b/util/path.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -19,10 +22,14 @@ import (
 	"fmt"
 	"reflect"
 	"strings"
+	"sync"
 
 	"github.com/openconfig/goyang/pkg/yang"
 )
 
+var pathToSchemaCache map[reflect.StructTag][]string = make(map[reflect.StructTag][]string)
+var pathToSchemaMutex sync.RWMutex
+
 // SchemaPaths returns all the paths in the path tag.
 func SchemaPaths(f reflect.StructField) ([][]string, error) {
 	var out [][]string
@@ -40,34 +47,52 @@ func SchemaPaths(f reflect.StructField) ([][]string, error) {
 
 // RelativeSchemaPath returns a path to the schema for the struct field f.
 // Paths are embedded in the "path" struct tag and can be either simple:
-//   e.g. "path:a"
+//
+//	e.g. "path:a"
+//
 // or composite (if path compression is used) e.g.
-//   e.g. "path:config/a|a"
+//
+//	e.g. "path:config/a|a"
+//
 // In the latter case, this function returns {"config", "a"}, because only the
 // longer path exists in the data tree and we want the schema for that node.
 // This case is found in OpenConfig leaf-ref cases where the key of a list is a
 // leafref; the schema *yang.Entry for the field is given by
 // schema.Dir["config"].Dir["a"].
 func RelativeSchemaPath(f reflect.StructField) ([]string, error) {
-	pathTag, ok := f.Tag.Lookup("path")
-	if !ok || pathTag == "" {
-		return nil, fmt.Errorf("field %s did not specify a path", f.Name)
-	}
+	pathToSchemaMutex.RLock()
+	if pe, ok := pathToSchemaCache[f.Tag]; ok {
+		pathToSchemaMutex.RUnlock()
+		return pe, nil
+	} else {
+		pathToSchemaMutex.RUnlock()
+		pathTag, ok := f.Tag.Lookup("path")
+		if !ok || pathTag == "" {
+			return nil, fmt.Errorf("field %s did not specify a path", f.Name)
+		}
 
-	paths := strings.Split(pathTag, "|")
-	if len(paths) == 1 {
-		pathTag = strings.TrimPrefix(pathTag, "/")
-		return strings.Split(pathTag, "/"), nil
-	}
-	for _, pv := range paths {
-		pv = strings.TrimPrefix(pv, "/")
-		pe := strings.Split(pv, "/")
-		if len(pe) > 1 {
-			return pe, nil
+		paths := strings.Split(pathTag, "|")
+		if len(paths) == 1 {
+			pathTag = strings.TrimPrefix(pathTag, "/")
+			retPath := strings.Split(pathTag, "/")
+			pathToSchemaMutex.Lock()
+			pathToSchemaCache[f.Tag] = retPath
+			pathToSchemaMutex.Unlock()
+			return retPath, nil
+		}
+		for _, pv := range paths {
+			pv = strings.TrimPrefix(pv, "/")
+			pe := strings.Split(pv, "/")
+			if len(pe) > 1 {
+				pathToSchemaMutex.Lock()
+				pathToSchemaCache[f.Tag] = pe
+				pathToSchemaMutex.Unlock()
+				return pe, nil
+			}
 		}
-	}
 
-	return nil, fmt.Errorf("field %s had path tag %s with |, but no elements of form a/b", f.Name, pathTag)
+		return nil, fmt.Errorf("field %s had path tag %s with |, but no elements of form a/b", f.Name, pathTag)
+	}
 }
 
 // SchemaTreePath returns the schema tree path of the supplied yang.Entry
@@ -174,10 +199,10 @@ func removeXPATHPredicates(s string) (string, error) {
 // FindLeafRefSchema returns a schema Entry at the path pathStr relative to
 // schema if it exists, or an error otherwise.
 // pathStr has either:
-//  - the relative form "../a/b/../b/c", where ".." indicates the parent of the
-//    node, or
-//  - the absolute form "/a/b/c", which indicates the absolute path from the
-//    root of the schema tree.
+//   - the relative form "../a/b/../b/c", where ".." indicates the parent of the
+//     node, or
+//   - the absolute form "/a/b/c", which indicates the absolute path from the
+//     root of the schema tree.
 func FindLeafRefSchema(schema *yang.Entry, pathStr string) (*yang.Entry, error) {
 	if pathStr == "" {
 		return nil, fmt.Errorf("leafref schema %s has empty path", schema.Name)
@@ -215,6 +240,10 @@ func FindLeafRefSchema(schema *yang.Entry, pathStr string) (*yang.Entry, error)
 		refSchema = refSchema.Dir[pe]
 	}
 
+	if refSchema.Type.Kind == yang.Yleafref {
+		return FindLeafRefSchema(refSchema, refSchema.Type.Path)
+	}
+
 	return refSchema, nil
 }
 
@@ -271,7 +300,7 @@ func StripModulePrefix(name string) string {
 // names. The path returned omits any leading or trailing empty elements when
 // splitting on the / character.
 func PathStringToElements(path string) []string {
-	parts := SplitPath(path)
+	parts := SplitPath2(path)
 	// Remove leading empty element
 	if len(parts) > 0 && parts[0] == "" {
 		parts = parts[1:]
@@ -283,6 +312,44 @@ func PathStringToElements(path string) []string {
 	return parts
 }
 
+// SplitPath2 splits path across unescaped /.
+// Any / inside square brackets are ignored.
+func SplitPath2(path string) []string {
+	var parts []string
+	var buf bytes.Buffer
+
+	var inKey, inEscape bool
+
+	var ch rune
+	for _, ch = range path {
+		switch {
+		case ch == '[' && !inEscape:
+			inKey = true
+		case ch == ']' && !inEscape:
+			inKey = false
+		case ch == '\\' && !inEscape:
+			inEscape = true
+			if inKey {
+				buf.WriteRune(ch)
+			}
+			continue
+		case ch == '/' && !inEscape && !inKey:
+			parts = append(parts, buf.String())
+			buf.Reset()
+			continue
+		}
+
+		buf.WriteRune(ch)
+		inEscape = false
+	}
+
+	if buf.Len() != 0 || (len(path) != 1 && ch == '/') {
+		parts = append(parts, buf.String())
+	}
+
+	return parts
+}
+
 // SplitPath splits path across unescaped /.
 // Any / inside square brackets are ignored.
 func SplitPath(path string) []string {
diff --git a/util/reflect.go b/util/reflect.go
index 6f9f3ea..457a245 100644
--- a/util/reflect.go
+++ b/util/reflect.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -191,8 +194,10 @@ func InsertIntoSlice(parentSlice interface{}, value interface{}) error {
 
 // InsertIntoMap inserts value with key into parent which must be a map.
 func InsertIntoMap(parentMap interface{}, key interface{}, value interface{}) error {
-	DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
-		parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    if debugLibrary {
+	   DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
+	      parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    }
 
 	v := reflect.ValueOf(parentMap)
 	t := reflect.TypeOf(parentMap)
@@ -283,7 +288,7 @@ func InsertIntoStruct(parentStruct interface{}, fieldName string, fieldValue int
 		n = reflect.Zero(ft.Type)
 	}
 
-	if !isFieldTypeCompatible(ft, n) {
+	if !isFieldTypeCompatible(ft, n) && !IsValueTypeCompatible(ft.Type, v) {
 		return fmt.Errorf("cannot assign value %v (type %T) to struct field %s (type %v) in struct %T", fieldValue, fieldValue, fieldName, ft.Type, parentStruct)
 	}
 
@@ -452,14 +457,36 @@ func DeepEqualDerefPtrs(a, b interface{}) bool {
 	return cmp.Equal(aa, bb)
 }
 
+func updateChildSchemaCache (schema *yang.Entry, tagStr reflect.StructTag, ygEntry *yang.Entry) {
+	schema.ChildSchemaMutex.Lock()		
+	schema.ChildSchemaCache[tagStr] = ygEntry
+	schema.ChildSchemaMutex.Unlock()
+}
+
 // ChildSchema returns the schema for the struct field f, if f contains a valid
 // path tag and the schema path is found in the schema tree. It returns an error
 // if the struct tag is invalid, or nil if tag is valid but the schema is not
 // found in the tree at the specified path.
 // TODO(wenbli): need unit test
 func ChildSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error) {
-	pathTag, _ := f.Tag.Lookup("path")
-	DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)
+	schema.ChildSchemaMutex.Lock()
+	if (schema.ChildSchemaCache == nil) {
+		schema.ChildSchemaCache = make(map[reflect.StructTag]*yang.Entry)
+	}
+	schema.ChildSchemaMutex.Unlock()
+
+	schema.ChildSchemaMutex.RLock()
+	if cschema, ok := schema.ChildSchemaCache[f.Tag]; ok {
+		schema.ChildSchemaMutex.RUnlock()
+		return cschema, nil
+	}
+	schema.ChildSchemaMutex.RUnlock()
+	
+	if IsDebugSchemaEnabled() {
+		pathTag, _ := f.Tag.Lookup("path")
+		DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)	
+	}
+	
 	p, err := RelativeSchemaPath(f)
 	if err != nil {
 		return nil, err
@@ -490,6 +517,7 @@ func ChildSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error)
 	}
 	if foundSchema {
 		DbgSchema(" - found\n")
+		updateChildSchemaCache (schema, f.Tag, childSchema)
 		return childSchema, nil
 	}
 	DbgSchema(" - not found\n")
@@ -505,11 +533,15 @@ func ChildSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error)
 		// path element i.e. choice1/case1/leaf1 path in the schema will have
 		// struct tag `path:"leaf1"`. This implies that only paths with length
 		// 1 are eligible for this matching.
+		updateChildSchemaCache (schema, f.Tag, nil)
 		return nil, nil
 	}
 	entries := FindFirstNonChoiceOrCase(schema)
 
-	DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+    if IsDebugSchemaEnabled() {
+		DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+    }
+    
 	for path, entry := range entries {
 		splitPath := SplitPath(path)
 		name := splitPath[len(splitPath)-1]
@@ -517,11 +549,13 @@ func ChildSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error)
 
 		if StripModulePrefix(name) == p[0] {
 			DbgSchema(" - match\n")
+			updateChildSchemaCache (schema, f.Tag, entry)
 			return entry, nil
 		}
 	}
 
 	DbgSchema(" - no matches\n")
+	updateChildSchemaCache (schema, f.Tag, nil)	
 	return nil, nil
 }
 
diff --git a/ygen/codegen.go b/ygen/codegen.go
index 991705e..66f1fe3 100644
--- a/ygen/codegen.go
+++ b/ygen/codegen.go
@@ -15,6 +15,10 @@
 // Package ygen contains a library to generate Go structs from a YANG model.
 // The Goyang parsing library is used to parse YANG. The output can consider
 // OpenConfig-specific conventions such that the schema is compressed.
+
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygen
 
 import (
@@ -946,7 +950,7 @@ func findMappableEntities(e *yang.Entry, dirs map[string]*yang.Entry, enums map[
 			dirs[ch.Path()] = ch
 			// Recurse down the tree.
 			errs = util.AppendErrs(errs, findMappableEntities(ch, dirs, enums, excludeModules, compressPaths, modules))
-		case ch.Kind == yang.AnyDataEntry:
+		case (ch.Kind == yang.AnyDataEntry), (ch.Kind == yang.NotificationEntry):	
 			continue
 		default:
 			errs = util.AppendErr(errs, fmt.Errorf("unknown type of entry %v in findMappableEntities for %s", e.Kind, e.Path()))
diff --git a/ygen/genstate.go b/ygen/genstate.go
index e39c478..b7766f0 100644
--- a/ygen/genstate.go
+++ b/ygen/genstate.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygen
 
 import (
@@ -83,6 +86,7 @@ func newEnumGenState() *enumGenState {
 // noUnderscores boolean.
 func (s *enumGenState) enumeratedUnionEntry(e *yang.Entry, compressPaths, noUnderscores bool) ([]*yangEnum, error) {
 	var es []*yangEnum
+	enumSet := make(map[string]*yangEnum)
 
 	for _, t := range util.EnumeratedUnionTypes(e.Type.Type) {
 		var en *yangEnum
@@ -111,20 +115,36 @@ func (s *enumGenState) enumeratedUnionEntry(e *yang.Entry, compressPaths, noUnde
 				}
 			}
 
-			en = &yangEnum{
-				name: enumName,
-				entry: &yang.Entry{
-					Name: e.Name,
-					Type: &yang.YangType{
-						Name: e.Type.Name,
-						Kind: yang.Yenum,
-						Enum: t.Enum,
+			if tmpEn, ok := enumSet[enumName]; ok {
+				enumTmp := yang.NewEnumType()
+				for eNm, eVal := range t.Enum.NameMap() {
+					if err := enumTmp.Set(eNm, eVal); err != nil {
+						return nil, fmt.Errorf("%v", err)
+					}
+				}
+				for eNm, eVal := range tmpEn.entry.Type.Enum.NameMap() {
+					if err := enumTmp.Set(eNm, eVal); err != nil {
+						return nil, fmt.Errorf("%v", err)
+					}
+				}
+				tmpEn.entry.Type.Enum = enumTmp
+				continue
+			} else {
+				en = &yangEnum{
+					name: enumName,
+					entry: &yang.Entry{
+						Name: e.Name,
+						Type: &yang.YangType{
+							Name: e.Type.Name,
+							Kind: yang.Yenum,
+							Enum: t.Enum,
+						},
+						Annotation: map[string]interface{}{"valuePrefix": util.SchemaPathNoChoiceCase(e)},
 					},
-					Annotation: map[string]interface{}{"valuePrefix": util.SchemaPathNoChoiceCase(e)},
-				},
+				}
+				enumSet[enumName] = en
 			}
 		}
-
 		es = append(es, en)
 	}
 
diff --git a/ygen/schemaparse.go b/ygen/schemaparse.go
index f71e7e6..800ec60 100644
--- a/ygen/schemaparse.go
+++ b/ygen/schemaparse.go
@@ -43,10 +43,28 @@ func buildJSONTree(ms []*yang.Entry, dn map[string]string, fakeroot *yang.Entry,
 	}
 	for _, m := range ms {
 		annotateChildren(m, dn)
+
+		// a leaf with a different prefix
+		if len(m.Dir) == 0 {
+			if _, found := m.Annotation["modulename"]; found {
+				rootEntry.Dir[m.Name] = m
+			}
+		}
+
 		for _, ch := range util.Children(m) {
 			if _, ex := rootEntry.Dir[ch.Name]; ex {
 				return nil, fmt.Errorf("overlapping root children for key %s", ch.Name)
 			}
+
+			ch.Annotation["namespace"] = m.Namespace().Name
+			ch.Annotation["modulename"] = m.Prefix.Parent.NName()
+			ch.Annotation["revision"] = m.Prefix.Parent.(*yang.Module).Current()
+			if m.Prefix.Parent.(*yang.Module).Organization != nil {
+				ch.Annotation["organization"] = m.Prefix.Parent.(*yang.Module).Organization.Name
+			} else {
+				ch.Annotation["organization"] = ""
+			}
+
 			rootEntry.Dir[ch.Name] = ch
 		}
 	}
@@ -101,6 +119,7 @@ func annotateChildren(e *yang.Entry, dn map[string]string) {
 //    corresponds to a YANG directory.
 func annotateEntry(e *yang.Entry, dn map[string]string) {
 	e.Description = ""
+	e.Augmented = nil
 	if e.Annotation == nil {
 		e.Annotation = map[string]interface{}{}
 	}
@@ -110,6 +129,11 @@ func annotateEntry(e *yang.Entry, dn map[string]string) {
 	if e.IsDir() {
 		e.Annotation["schemapath"] = e.Path()
 	}
+	// add the modulename if the prefix is different from its parent
+	// and it belong to "module" only, i.e. filter out submodule
+	if e.Parent != nil && e.Namespace().Name != e.Parent.Namespace().Name && e.Prefix.Parent.Statement().Keyword == "module" {
+		e.Annotation["modulename"] = e.Prefix.Parent.NName()
+	}
 }
 
 // WriteGzippedByteSlice takes an input slice of bytes, gzips it
diff --git a/ygot/render.go b/ygot/render.go
index 0d649c3..393e7fa 100644
--- a/ygot/render.go
+++ b/ygot/render.go
@@ -20,6 +20,7 @@ import (
 	"fmt"
 	"reflect"
 	"sort"
+	"strconv"
 	"strings"
 
 	"github.com/golang/protobuf/proto"
@@ -45,6 +46,11 @@ type path struct {
 	p *gnmiPath
 }
 
+type structTagInfo struct {
+	gPathList []*gnmiPath
+	chModName string
+}
+
 func (p *path) String() string {
 	if p.p.isPathElemPath() {
 		return proto.MarshalTextString(&gnmipb.Path{Elem: p.p.pathElemPath})
@@ -272,6 +278,8 @@ type GNMINotificationsConfig struct {
 	// of PathElem messages. This path format is used by gNMI 0.4.0 and
 	// above. Used if PathElem is set.
 	PathElemPrefix []*gnmipb.PathElem
+	// Encoding to be used for atomic values - like keyless lists
+	Encoding gnmipb.Encoding
 }
 
 // TogNMINotifications takes an input GoStruct and renders it to slice of
@@ -297,7 +305,7 @@ func TogNMINotifications(s GoStruct, ts int64, cfg GNMINotificationsConfig) ([]*
 		return nil, err
 	}
 
-	msgs, err := leavesToNotifications(leaves, ts, pfx)
+	msgs, err := leavesToNotifications(leaves, ts, pfx, cfg.Encoding)
 	if err != nil {
 		return nil, err
 	}
@@ -379,6 +387,13 @@ func findUpdatedLeaves(leaves map[*path]interface{}, s GoStruct, parent *gnmiPat
 			}
 		case reflect.Slice:
 			if fval.Type().Elem().Kind() == reflect.Ptr {
+				// s is a container with single keyless list. Add the whole container
+				if sval.NumField() == 1 {
+					for _, p := range mapPaths {
+						leaves[&path{p}] = s
+					}
+					continue
+				}
 				// This is a keyless list - currently unsupported for mapping since there is
 				// not an explicit path that can be used.
 				errs.Add(fmt.Errorf("unimplemented: keyless list cannot be output: %v", mapPaths[0]))
@@ -591,7 +606,7 @@ func sliceToScalarArray(v []interface{}) (*gnmipb.ScalarArray, error) {
 // likely to be suboptimal since it results in very large Notifications for particular
 // structs. There should be some fragmentation of Updates across Notification messages
 // in a future implementation. We return a slice to keep the API stable.
-func leavesToNotifications(leaves map[*path]interface{}, ts int64, pfx *gnmiPath) ([]*gnmipb.Notification, error) {
+func leavesToNotifications(leaves map[*path]interface{}, ts int64, pfx *gnmiPath, enc gnmipb.Encoding) ([]*gnmipb.Notification, error) {
 	n := &gnmipb.Notification{
 		Timestamp: ts,
 	}
@@ -613,7 +628,7 @@ func leavesToNotifications(leaves map[*path]interface{}, ts int64, pfx *gnmiPath
 			return nil, err
 		}
 
-		val, err := EncodeTypedValue(v, gnmipb.Encoding_JSON)
+		val, err := EncodeTypedValue(v, enc)
 		if err != nil {
 			return nil, err
 		}
@@ -713,7 +728,7 @@ func marshalStruct(s GoStruct, enc gnmipb.Encoding) (*gnmipb.TypedValue, error)
 		return nil, err
 	}
 
-	js, err := json.MarshalIndent(j, "", "  ")
+	js, err := json.Marshal(j)
 	if err != nil {
 		return nil, fmt.Errorf("cannot encode JSON, %v", err)
 	}
@@ -870,19 +885,21 @@ type RFC7951JSONConfig struct {
 // the module name should be appended to entities that are defined in a different
 // module to their parent.
 func ConstructIETFJSON(s GoStruct, args *RFC7951JSONConfig) (map[string]interface{}, error) {
+	tagPaths := map[reflect.StructTag]*structTagInfo{}
 	return structJSON(s, "", jsonOutputConfig{
 		jType:         RFC7951,
 		rfc7951Config: args,
-	})
+	}, tagPaths)
 }
 
 // ConstructInternalJSON marshals a supplied GoStruct to a map, suitable for handing
-// to json.Marshal. It uses the loosely specified JSON format document in
+// to json.Marshal. It usstres the loosely specified JSON format document in
 // go/yang-internal-json.
 func ConstructInternalJSON(s GoStruct) (map[string]interface{}, error) {
+	tagPaths := map[reflect.StructTag]*structTagInfo{}
 	return structJSON(s, "", jsonOutputConfig{
 		jType: Internal,
-	})
+	}, tagPaths)
 }
 
 // jsonOutputConfig is used to determine how constructJSON should generate
@@ -902,7 +919,7 @@ type jsonOutputConfig struct {
 // be produced and whether such module names are appended is controlled through the
 // supplied jsonOutputConfig. Returns an error if the GoStruct cannot be rendered
 // to JSON.
-func structJSON(s GoStruct, parentMod string, args jsonOutputConfig) (map[string]interface{}, error) {
+func structJSON(s GoStruct, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (map[string]interface{}, error) {
 	var errs errlist.List
 
 	sval := reflect.ValueOf(s).Elem()
@@ -916,20 +933,51 @@ func structJSON(s GoStruct, parentMod string, args jsonOutputConfig) (map[string
 		field := sval.Field(i)
 		fType := stype.Field(i)
 
+		switch field.Kind() {
+		case reflect.Map, reflect.Slice, reflect.Ptr, reflect.Interface:
+			if field.IsNil() {
+				continue
+			}
+		}
+
 		// Determine whether we should append a module name to the path in RFC7951
 		// output mode.
 		var appmod string
+
 		pmod := parentMod
-		if chMod, ok := fType.Tag.Lookup("module"); ok {
-			// If the child module isn't the same as the parent module,
-			// then appmod stores the name of the module to prefix to paths
-			// within this context.
-			if chMod != parentMod {
-				appmod = chMod
+
+		var mapPaths []*gnmiPath
+		var err error
+
+		if tagInfo, ok := tagPaths[fType.Tag]; !ok {
+			tagInfoObj := new(structTagInfo)
+			tagInfoObj.gPathList, err = structTagToLibPaths(fType, newStringSliceGNMIPath([]string{}))
+			if err != nil {
+				errs.Add(fmt.Errorf("%s: %v", fType.Name, err))
+				continue
+			}
+			if chMod, modOk := fType.Tag.Lookup("module"); modOk {
+				// If the child module isn't the same as the parent module,
+				// then appmod stores the name of the module to prefix to pathsmakejson
+				// within this context.
+				if chMod != parentMod {
+					appmod = chMod
+				}
+				// Update the parent module name to be used for subsequent
+				// children.
+				pmod = chMod
+				tagInfoObj.chModName = chMod
+			} else {
+				tagInfoObj.chModName = pmod
+			}
+			tagPaths[fType.Tag] = tagInfoObj
+			mapPaths = tagInfoObj.gPathList
+		} else {
+			mapPaths = tagInfo.gPathList
+			pmod = tagInfo.chModName
+			if tagInfo.chModName != parentMod {
+				appmod = tagInfo.chModName
 			}
-			// Update the parent module name to be used for subsequent
-			// children.
-			pmod = chMod
 		}
 
 		var appendModName bool
@@ -937,19 +985,8 @@ func structJSON(s GoStruct, parentMod string, args jsonOutputConfig) (map[string
 			appendModName = true
 		}
 
-		mapPaths, err := structTagToLibPaths(fType, newStringSliceGNMIPath([]string{}))
-		if err != nil {
-			errs.Add(fmt.Errorf("%s: %v", fType.Name, err))
-			continue
-		}
-
 		var value interface{}
-
-		if util.IsYgotAnnotation(fType) {
-			value, err = jsonAnnotationSlice(field)
-		} else {
-			value, err = jsonValue(field, pmod, args)
-		}
+		value, err = jsonValue(field, pmod, args, tagPaths)
 
 		if err != nil {
 			errs.Add(err)
@@ -1058,7 +1095,10 @@ func structJSON(s GoStruct, parentMod string, args jsonOutputConfig) (map[string
 // and float64 values are represented as strings.
 func writeIETFScalarJSON(i interface{}) interface{} {
 	switch reflect.ValueOf(i).Kind() {
-	case reflect.Uint64, reflect.Int64, reflect.Float64:
+	case reflect.Float64:
+		val, _ := i.(float64)
+		return strconv.FormatFloat(val, 'f', -1, 64)
+	case reflect.Uint64, reflect.Int64:
 		return fmt.Sprintf("%v", i)
 	}
 	return i
@@ -1086,7 +1126,7 @@ func keyValue(v reflect.Value, appendModuleName bool) (interface{}, error) {
 // constructs the representation for JSON marshalling that corresponds to it.
 // The module within which the map is defined is specified by the parentMod
 // argument.
-func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	var errs errlist.List
 	mapKeyMap := map[string]reflect.Value{}
 	// Order of elements determines the order in which keys will be processed.
@@ -1155,6 +1195,7 @@ func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig) (inte
 	default:
 		return nil, fmt.Errorf("invalid JSON format specified: %v", args.jType)
 	}
+
 	for _, kn := range mapKeys {
 		k := mapKeyMap[kn]
 		goStruct, ok := field.MapIndex(k).Interface().(GoStruct)
@@ -1163,7 +1204,7 @@ func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig) (inte
 			continue
 		}
 
-		val, err := structJSON(goStruct, parentMod, args)
+		val, err := structJSON(goStruct, parentMod, args, tagPaths)
 		if err != nil {
 			errs.Add(err)
 			continue
@@ -1191,7 +1232,7 @@ func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig) (inte
 // The module within which the value is defined is specified by the parentMod string,
 // and the type of JSON to be rendered controlled by the value of the jsonOutputConfig
 // provided. Returns an error if one occurs during the mapping process.
-func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	var value interface{}
 	var errs errlist.List
 
@@ -1210,7 +1251,7 @@ func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (in
 	switch field.Kind() {
 	case reflect.Map:
 		var err error
-		value, err = mapJSON(field, parentMod, args)
+		value, err = mapJSON(field, parentMod, args, tagPaths)
 		if err != nil {
 			errs.Add(err)
 		}
@@ -1223,7 +1264,7 @@ func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (in
 			}
 
 			var err error
-			value, err = structJSON(goStruct, parentMod, args)
+			value, err = structJSON(goStruct, parentMod, args, tagPaths)
 			if err != nil {
 				errs.Add(err)
 			}
@@ -1235,7 +1276,7 @@ func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (in
 		}
 	case reflect.Slice:
 		var err error
-		value, err = jsonSlice(field, parentMod, args)
+		value, err = jsonSlice(field, parentMod, args, tagPaths)
 		if err != nil {
 			return nil, err
 		}
@@ -1289,7 +1330,7 @@ func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (in
 // GoStruct, a slice may be a binary field, leaf-list or an unkeyed list. The
 // parentMod is used to track the name of the parent module in the case that
 // module names should be appended.
-func jsonSlice(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func jsonSlice(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	if field.Type().Name() == BinaryTypeName {
 		// Handle the case that that we have a Binary ([]byte) value,
 		// which must be returned as a JSON string.
@@ -1305,7 +1346,7 @@ func jsonSlice(field reflect.Value, parentMod string, args jsonOutputConfig) (in
 			if !ok {
 				return nil, fmt.Errorf("invalid member of a slice, %s was not a valid GoStruct", c.Name())
 			}
-			j, err := structJSON(gs, parentMod, args)
+			j, err := structJSON(gs, parentMod, args, tagPaths)
 			if err != nil {
 				return nil, err
 			}
diff --git a/ygot/struct_validation_map.go b/ygot/struct_validation_map.go
index d3e54b9..6d16641 100644
--- a/ygot/struct_validation_map.go
+++ b/ygot/struct_validation_map.go
@@ -19,6 +19,10 @@
 //	  to return pointers to a type.
 //	- Renders structs to other output formats such as JSON, or gNMI
 //	  notifications.
+
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygot
 
 import (
@@ -336,31 +340,12 @@ type EmitJSONConfig struct {
 // EmitJSON takes an input ValidatedGoStruct (produced by ygen with validation enabled)
 // and serialises it to a JSON string. By default, produces the Internal format JSON.
 func EmitJSON(s ValidatedGoStruct, opts *EmitJSONConfig) (string, error) {
-	var (
-		vopts          []ValidationOption
-		skipValidation bool
-	)
-
-	if opts != nil {
-		vopts = opts.ValidationOpts
-		skipValidation = opts.SkipValidation
-	}
-
-	if err := s.Validate(vopts...); !skipValidation && err != nil {
-		return "", fmt.Errorf("validation err: %v", err)
-	}
-
 	v, err := makeJSON(s, opts)
 	if err != nil {
 		return "", err
 	}
 
-	indent := indentString
-	if opts != nil && opts.Indent != "" {
-		indent = opts.Indent
-	}
-
-	j, err := json.MarshalIndent(v, "", indent)
+	j, err := json.Marshal(v)
 	if err != nil {
 		return "", fmt.Errorf("JSON marshalling error: %v", err)
 	}
@@ -525,7 +510,6 @@ func copyStruct(dstVal, srcVal reflect.Value) error {
 	for i := 0; i < srcVal.NumField(); i++ {
 		srcField := srcVal.Field(i)
 		dstField := dstVal.Field(i)
-
 		switch srcField.Kind() {
 		case reflect.Ptr:
 			if err := copyPtrField(dstField, srcField); err != nil {
@@ -555,7 +539,13 @@ func copyStruct(dstVal, srcVal reflect.Value) error {
 				dstField.Set(srcField)
 			}
 		default:
-			dstField.Set(srcField)
+                    if srcField.Type().Implements(reflect.TypeOf((*GoEnum)(nil)).Elem()) == true {
+                        if srcField.Int() != 0 {
+                            dstField.Set(srcField)
+                        }
+                    } else {
+                        dstField.Set(srcField)
+                    }
 		}
 	}
 	return nil
@@ -595,6 +585,7 @@ func copyPtrField(dstField, srcField reflect.Value) error {
 			return err
 		}
 		dstField.Set(d)
+		
 		return nil
 	}
 
@@ -608,6 +599,7 @@ func copyPtrField(dstField, srcField reflect.Value) error {
 	p := reflect.New(srcField.Type().Elem())
 	p.Elem().Set(srcField.Elem())
 	dstField.Set(p)
+	
 	return nil
 }
 
@@ -636,6 +628,7 @@ func copyInterfaceField(dstField, srcField reflect.Value) error {
 		return err
 	}
 	dstField.Set(d)
+
 	return nil
 }
 
@@ -645,6 +638,7 @@ func copyInterfaceField(dstField, srcField reflect.Value) error {
 // key is populated in srcField and dstField, their contents are merged if they
 // do not overlap, otherwise an error is returned.
 func copyMapField(dstField, srcField reflect.Value) error {
+
 	if !util.IsValueMap(srcField) {
 		return fmt.Errorf("received a non-map type in src map field: %v", srcField.Kind())
 	}
@@ -664,8 +658,6 @@ func copyMapField(dstField, srcField reflect.Value) error {
 	}
 
 	srcKeys := srcField.MapKeys()
-	dstKeys := dstField.MapKeys()
-
 	nm := reflect.MakeMapWithSize(reflect.MapOf(m.key, m.value), srcField.Len())
 
 	mapsToMap := []struct {
@@ -673,20 +665,24 @@ func copyMapField(dstField, srcField reflect.Value) error {
 		field reflect.Value
 	}{
 		{srcKeys, srcField},
-		{dstKeys, dstField},
 	}
 	existingKeys := map[interface{}]reflect.Value{}
 
+	for _, dstKey := range dstField.MapKeys()  {
+		existingKeys[dstKey.Interface()] = dstField.MapIndex(dstKey)
+	}
+	
 	for _, m := range mapsToMap {
 		for _, k := range m.keys {
 			// If the key already exists, then determine the existing item to merge
 			// into.
 			v := m.field.MapIndex(k)
 			var d reflect.Value
-			var ok bool
-			if d, ok = existingKeys[k.Interface()]; !ok {
+			if tmpVal, keyErr := compareMapKeys(existingKeys, k.Interface()); keyErr != nil {
 				d = reflect.New(v.Elem().Type())
 				existingKeys[k.Interface()] = v
+			} else {
+				d = *tmpVal
 			}
 
 			if err := copyStruct(d.Elem(), v.Elem()); err != nil {
@@ -804,3 +800,12 @@ func uniqueSlices(a, b reflect.Value) (bool, error) {
 	}
 	return true, nil
 }
+
+func compareMapKeys(existingKeys map[interface{}]reflect.Value, searchKey interface{}) (*reflect.Value, error) {
+	for tmpKey, tmpVal := range existingKeys  {
+		if cmp.Equal(tmpKey, searchKey) {
+			return &tmpVal, nil
+		}		
+	}
+	return nil, fmt.Errorf("No match found in the existingKeys map.")
+}
diff --git a/ytypes/container.go b/ytypes/container.go
index 9864a2c..3209c78 100644
--- a/ytypes/container.go
+++ b/ytypes/container.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -69,9 +72,13 @@ func validateContainer(schema *yang.Entry, value ygot.GoStruct) util.Errors {
 			case cschema != nil:
 				// Regular named child.
 				if errs := Validate(cschema, fieldValue); errs != nil {
-					errors = util.AppendErrs(errors, util.PrefixErrors(errs, cschema.Path()))
+					if errs.Error() != "ERROR_READONLY_OBJECT_FOUND" {
+						errors = util.AppendErrs(errors, util.PrefixErrors(errs, cschema.Path()))
+					} else if len(errors) == 0 {
+						errors = util.AppendErrs(errors, errs)
+					}
 				}
-			case !util.IsValueNilOrDefault(structElems.Field(i).Interface()):
+			case !structElems.Field(i).IsNil():
 				// Either an element in choice schema subtree, or bad field.
 				// If the former, it will be found in the choice check below.
 				extraFields[fieldName] = nil
@@ -101,6 +108,10 @@ func validateContainer(schema *yang.Entry, value ygot.GoStruct) util.Errors {
 		errors = util.AppendErr(errors, fmt.Errorf("fields %v are not found in the container schema %s", stringMapSetToSlice(extraFields), schema.Name))
 	}
 
+	if len(errors) == 0 && schema.ReadOnly() == true {
+		errors = util.AppendErrs(errors, util.NewErrs(fmt.Errorf("ERROR_READONLY_OBJECT_FOUND")))
+	}
+
 	return util.UniqueErrors(errors)
 }
 
@@ -138,6 +149,94 @@ func unmarshalContainer(schema *yang.Entry, parent interface{}, jsonTree interfa
 	return unmarshalStruct(schema, parent, jt, enc, opts...)
 }
 
+// unmarshalKeyFieldsInStruct unmarshals a JSON tree into a struct only for the Key fields.
+// schema is the YANG schema of the node corresponding to the struct being unmarshalled into.
+// mapParent is the interface which of type map holds this parent struct with the key
+// parent is the parent struct, which must be a struct ptr.
+// jsonTree is a JSON data tree which must be a map[string]interface{}.
+// returns key as formatted string, else error
+func unmarshalKeyFieldsInStruct(schema *yang.Entry, mapParent interface{}, parent interface{}, jsonTree map[string]interface{}, enc Encoding, opts ...UnmarshalOpt) (string, error) {
+	destv := reflect.ValueOf(parent).Elem()
+
+	keySet := make(map[string]bool)
+	listKeyType := reflect.TypeOf(mapParent).Key()
+	if util.IsTypeStruct(listKeyType) {
+		newKey := reflect.New(listKeyType).Elem()
+		for i := 0; i < newKey.NumField(); i++ {
+			keySet[listKeyType.Field(i).Name] = true
+		}
+	} else {
+		if fName, err := schemaNameToFieldName(destv, schema.Key); err == nil {
+			keySet[fName] = true
+		}
+	}
+
+	keyStr := ""
+	// Range over the parent struct fields. For each field, check if the data
+	// is present in the JSON tree and if so unmarshal it into the field.
+	for i := 0; i < destv.NumField(); i++ {
+		f := destv.Field(i)
+		ft := destv.Type().Field(i)
+		if _, ok := keySet[ft.Name]; !ok {
+			continue
+		}
+		// Skip annotation fields since they do not have a schema.
+		// TODO(robjs): Implement unmarshalling annotations.
+		if util.IsYgotAnnotation(ft) {
+			continue
+		}
+
+		cschema, err := util.ChildSchema(schema, ft)
+		if err != nil {
+			return "", err
+		}
+		if cschema == nil {
+			return "", fmt.Errorf("unmarshalContainer could not find schema for type %T, field name %s", parent, ft.Name)
+		}
+		jsonValue, err := getJSONTreeValForField(schema, cschema, ft, jsonTree)
+		if err != nil {
+			return "", err
+		}
+		// Store the data tree path of the current field. These will be used
+		// at the end to ensure that there are no excess elements in the JSON
+		// tree not covered by any data path.
+		sp, err := dataTreePaths(schema, cschema, ft)
+		if err != nil {
+			return "", err
+		}
+		if jsonValue == nil {
+			util.DbgPrint("field %s paths %v not present in tree", ft.Name, sp)
+			continue
+		}
+		keyStr = keyStr + fmt.Sprintf("%v", jsonValue) + "#"
+		util.DbgPrint("populating field %s type %s with paths %v.", ft.Name, ft.Type, sp)
+		// Only create a new field if it is nil, otherwise update just the
+		// fields that are in the data tree being passed to unmarshal, and
+		// preserve all other existing values.
+		if util.IsNilOrInvalidValue(f) {
+			makeField(destv, ft)
+		}
+
+		p := parent
+		switch {
+		case util.IsUnkeyedList(cschema):
+			// For unkeyed list, we must pass in the addr of the slice to be
+			// able to append to it.
+			p = f.Addr().Interface()
+		case cschema.IsContainer() || cschema.IsList():
+			// For list and container, the new parent is the field we just
+			// created. For leaf and leaf-list, the parent is still the
+			// current container.
+			p = f.Interface()
+		}
+		if err := unmarshalGeneric(cschema, p, jsonValue, enc, opts...); err != nil {
+			return "", err
+		}
+	}
+
+	return keyStr, nil
+}
+
 // unmarshalStruct unmarshals a JSON tree into a struct.
 //   schema is the YANG schema of the node corresponding to the struct being
 //     unmarshalled into.
@@ -217,7 +316,10 @@ func unmarshalStruct(schema *yang.Entry, parent interface{}, jsonTree map[string
 		}
 	}
 
-	util.DbgPrint("container after unmarshal:\n%s\n", pretty.Sprint(destv.Interface()))
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("container after unmarshal:\n%s\n", pretty.Sprint(destv.Interface()))
+	}
+
 	return nil
 }
 
diff --git a/ytypes/leaf.go b/ytypes/leaf.go
index 1d4195a..55de85c 100644
--- a/ytypes/leaf.go
+++ b/ytypes/leaf.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -20,11 +23,13 @@ import (
 	"math/big"
 	"reflect"
 	"strconv"
+	"strings"
 
 	log "github.com/golang/glog"
 	"github.com/openconfig/goyang/pkg/yang"
 	"github.com/openconfig/ygot/util"
 	"github.com/openconfig/ygot/ygot"
+	"github.com/openconfig/gnmi/value"
 
 	gpb "github.com/openconfig/gnmi/proto/gnmi"
 )
@@ -77,7 +82,7 @@ func validateLeaf(inSchema *yang.Entry, value interface{}) util.Errors {
 
 	switch ykind {
 	case yang.Ybinary:
-		return util.NewErrs(validateBinary(schema, value))
+		return util.NewErrs(validateBinary(schema, rv))
 	case yang.Ybits:
 		return nil
 		// TODO(mostrowski): restore when representation is decided.
@@ -258,7 +263,7 @@ func validateUnion(schema *yang.Entry, value interface{}) util.Errors {
 // during validation against each matching schema otherwise.
 func validateMatchingSchemas(schema *yang.Entry, value interface{}) util.Errors {
 	var errors []error
-	ss := findMatchingSchemasInUnion(schema.Type, value)
+	ss := findMatchingSchemasInUnion(schema, schema.Type, value)
 	var kk []yang.TypeKind
 	for _, s := range ss {
 		kk = append(kk, s.Type.Kind)
@@ -289,17 +294,25 @@ func validateMatchingSchemas(schema *yang.Entry, value interface{}) util.Errors
 // findMatchingSchemasInUnion returns all schemas in the given union type,
 // including those within nested unions, that match the Go type of value.
 // value must not be nil.
-func findMatchingSchemasInUnion(ytype *yang.YangType, value interface{}) []*yang.Entry {
+func findMatchingSchemasInUnion(schema *yang.Entry, ytype *yang.YangType, value interface{}) []*yang.Entry {
 	var matches []*yang.Entry
 
 	util.DbgPrint("findMatchingSchemasInUnion for type %T, kind %s", value, reflect.TypeOf(value).Kind())
 	for _, t := range ytype.Type {
 		if t.Kind == yang.Yunion {
 			// Recursively check all union types within this union.
-			matches = append(matches, findMatchingSchemasInUnion(t, value)...)
+			matches = append(matches, findMatchingSchemasInUnion(schema, t, value)...)
 			continue
 		}
 
+		if t.Kind == yang.Yleafref {
+			ns, err := util.FindLeafRefSchema(schema, t.Path)
+			if err != nil {
+				log.Warningf("not found base Go type for type %v in union value %s", t.Kind, util.ValueStr(value))
+				continue
+			}
+			t = ns.Type
+		}
 		ybt := yangBuiltinTypeToGoType(t.Kind)
 		if reflect.ValueOf(value).Kind() == reflect.Ptr {
 			ybt = ygot.ToPtr(yangBuiltinTypeToGoType(t.Kind))
@@ -467,8 +480,11 @@ func unmarshalUnion(schema *yang.Entry, parent interface{}, fieldName string, va
 		default:
 			return fmt.Errorf("got %v non-enum types and %v enum types for union schema %s for type %T, expect just one type in total", sks, ets, fieldName, parent)
 		}
-
-		goValue, err := unmarshalScalar(parent, yangKindToLeafEntry(yk), fieldName, value, enc)
+		
+		ygEntry := yangKindToLeafEntry(yk)
+		ygEntry.Name = schema.Name
+		ygEntry.Parent = schema.Parent
+		goValue, err := unmarshalScalar(parent, ygEntry, fieldName, value, enc)
 		if err != nil {
 			return fmt.Errorf("could not unmarshal %v into type %s", value, yk)
 		}
@@ -533,6 +549,8 @@ func unmarshalUnion(schema *yang.Entry, parent interface{}, fieldName string, va
 	for _, sk := range sks {
 		util.DbgPrint("try to unmarshal into type %s", sk)
 		sch := yangKindToLeafEntry(sk)
+		sch.Parent = schema.Parent
+		sch.Name = schema.Name
 		gv, err := unmarshalScalar(parent, sch, fieldName, value, enc)
 		if err == nil {
 			return setFieldWithTypedValue(parentT, destUnionFieldV, destUnionFieldElemT, gv)
@@ -632,22 +650,24 @@ func getUnionTypesNotEnums(schema *yang.Entry, yt *yang.YangType) ([]*yang.YangT
 // type) for a given schema, which must be for an enum type. t is the type of
 // the containing parent struct.
 func schemaToEnumTypes(schema *yang.Entry, t reflect.Type) ([]reflect.Type, error) {
-	enumTypesMethod := reflect.New(t).Elem().MethodByName("ΛEnumTypeMap")
+	enumTypesMethod := reflect.New(t).Elem().MethodByName("\u039bEnumTypeMap")
 	if !enumTypesMethod.IsValid() {
-		return nil, fmt.Errorf("type %s does not have a ΛEnumTypesMap function", t)
+		return nil, fmt.Errorf("type %s does not have a \u039bEnumTypesMap function", t)
 	}
 
 	ec := enumTypesMethod.Call(nil)
 	if len(ec) == 0 {
-		return nil, fmt.Errorf("%s ΛEnumTypes function returns empty value", t)
+		return nil, fmt.Errorf("%s \u039bEnumTypes function returns empty value", t)
 	}
 	ei := ec[0].Interface()
 	enumTypesMap, ok := ei.(map[string][]reflect.Type)
 	if !ok {
-		return nil, fmt.Errorf("%s ΛEnumTypes function returned wrong type %T, want map[string][]reflect.Type", t, ei)
+		return nil, fmt.Errorf("%s \u039bEnumTypes function returned wrong type %T, want map[string][]reflect.Type", t, ei)
 	}
 
-	util.DbgPrint("path is %s for schema %s", absoluteSchemaDataPath(schema), schema.Name)
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("path is %s for schema %s", absoluteSchemaDataPath(schema), schema.Name)	
+	}
 
 	return enumTypesMap[absoluteSchemaDataPath(schema)], nil
 }
@@ -770,6 +790,65 @@ func sanitizeJSON(parent interface{}, schema *yang.Entry, fieldName string, valu
 	return nil, fmt.Errorf("unmarshalScalar: unsupported type %v in schema node %s", ykind, schema.Name)
 }
 
+func yangTypeToGoTypeVal (parent interface{}, schema *yang.Entry, fieldName string, value interface{}) (interface{}, error) {
+	ykind := schema.Type.Kind
+
+	switch ykind {
+	case yang.Ybinary:
+		v, err := base64.StdEncoding.DecodeString(value.(string))
+		if err != nil {
+			return nil, fmt.Errorf("Error in Decode String for \n%v\n for schema %s: %v", value, schema.Name, err)
+		}
+		return []byte(v), nil
+
+	case yang.Ybool:
+		if strings.ToLower(value.(string)) == "false" {
+			return false, nil
+		} else if strings.ToLower(value.(string)) == "true" {
+			return true, nil
+		} else {
+			return nil, fmt.Errorf("Error in converting to yang bool type for the value for \n%v\n for schema %s", value, schema.Name)
+		}
+
+	case yang.Ystring:
+		return value.(string), nil
+
+	case yang.Ydecimal64:
+		floatV, err := strconv.ParseFloat(value.(string), 64)
+		if err != nil {
+			return nil, fmt.Errorf("Error parsing %v for schema %s: %v", value, schema.Name, err)
+		}
+		return floatV, nil
+
+	case yang.Yenum, yang.Yidentityref:
+		return enumStringToValue(parent, fieldName, value.(string))
+
+	case yang.Yint64:
+		// TODO(b/64812268): value types are different for internal style JSON.
+		intV, err := strconv.ParseInt(value.(string), 10, 64)
+		if err != nil {
+			return nil, fmt.Errorf("Error parsing %v for schema %s: %v", value, schema.Name, err)
+		}
+		return intV, nil
+
+	case yang.Yuint64:
+		uintV, err := strconv.ParseUint(value.(string), 10, 64)
+		if err != nil {
+			return nil, fmt.Errorf("Error parsing %v for schema %s: %v", value, schema.Name, err)
+		}
+		return uintV, nil
+
+	case yang.Yint8, yang.Yint16, yang.Yint32, yang.Yuint8, yang.Yuint16, yang.Yuint32:
+		gt := reflect.TypeOf(yangBuiltinTypeToGoType(ykind))
+		if rv, err := StringToType(gt, value.(string)); err != nil {
+			return nil, fmt.Errorf("Error StringToType:parsing %v for schema %s: %v", value, schema.Name, err)
+		} else {
+			return rv.Interface(), nil
+		}
+	}
+	return nil, fmt.Errorf("Error: unsupported type %v in schema node %s", ykind, schema.Name)
+}
+
 // sanitizeGNMI decodes the GNMI TypedValue encoded value into a field of the
 // corresponding type in GoStruct. Parent is the parent struct containing the
 // field being unmarshaled. schema is *yang.Entry corresponding to the field.
@@ -780,6 +859,18 @@ func sanitizeJSON(parent interface{}, schema *yang.Entry, fieldName string, valu
 func sanitizeGNMI(parent interface{}, schema *yang.Entry, fieldName string, tv *gpb.TypedValue, jsonTolerance bool) (interface{}, error) {
 	ykind := schema.Type.Kind
 
+	//get the original schema of the node and check whether it is leaf-list
+	if ygNode := schema.Parent.Dir[schema.Name]; ygNode != nil && ygNode.IsLeafList() {
+		// convert the leaf-list's value only if its of type string(TypedValue_StringVal)
+		if len(tv.GetStringVal()) > 0 {
+			if goVal, err := yangTypeToGoTypeVal (parent, schema, fieldName, tv.GetStringVal()); err == nil {
+				if gnmiTypeVal, err := value.FromScalar(goVal); err == nil {
+					tv = gnmiTypeVal
+				}			
+			}
+		}
+	}
+	
 	var ok bool
 	if ok = gNMIToYANGTypeMatches(ykind, tv, jsonTolerance); !ok {
 		return nil, fmt.Errorf("failed to unmarshal %v into %v", tv.GetValue(), yang.TypeKindToName[ykind])
@@ -875,4 +966,4 @@ func isValueInterfacePtrToEnum(v reflect.Value) bool {
 	v = v.Elem()
 
 	return v.Kind() == reflect.Int64
-}
+}
\ No newline at end of file
diff --git a/ytypes/list.go b/ytypes/list.go
index ec52ee3..4be52ea 100644
--- a/ytypes/list.go
+++ b/ytypes/list.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -19,6 +22,8 @@ import (
 	"reflect"
 	"strings"
 
+	log "github.com/golang/glog"
+	"github.com/google/go-cmp/cmp"
 	"github.com/kylelemons/godebug/pretty"
 	"github.com/openconfig/goyang/pkg/yang"
 	"github.com/openconfig/ygot/util"
@@ -217,6 +222,9 @@ func validateListSchema(schema *yang.Entry) error {
 		if len(schema.Key) == 0 {
 			return fmt.Errorf("list %s with config set must have a key", schema.Name)
 		}
+		if schema.IsSchemaValidated == true {
+			return nil
+		}
 		keys := strings.Fields(schema.Key)
 		keysMissing := make(map[string]bool)
 		for _, v := range keys {
@@ -232,6 +240,7 @@ func validateListSchema(schema *yang.Entry) error {
 		}
 	}
 
+	schema.IsSchemaValidated = true
 	return nil
 }
 
@@ -271,6 +280,31 @@ func nameMatchesPath(fieldName string, path []string) (bool, error) {
 	return false, fmt.Errorf("expected field %s path to have one or two elements, got %v", fieldName, path)
 }
 
+func isKeyHasStructPtr(key reflect.Value) bool {
+	switch key.Type().Kind() {
+	case reflect.Ptr:
+		return true
+	case reflect.Interface:
+		key = key.Elem()
+		switch key.Type().Kind() {
+		case reflect.Ptr:
+			return true
+		case reflect.Struct:
+		default:
+			return false
+		}
+	case reflect.Struct:
+	default:
+		return false
+	}
+	for i, n := 0, key.NumField(); i < n; i++ {
+		if isKeyHasStructPtr(key.Field(i)) {
+			return true
+		}
+	}
+	return false
+}
+
 // unmarshalList unmarshals a JSON array into a list parent, which must be a
 // map or slice ptr.
 //   schema is the schema of the schema node corresponding to the struct being
@@ -316,6 +350,22 @@ func unmarshalList(schema *yang.Entry, parent interface{}, jsonList interface{},
 	if !util.IsTypeStructPtr(listElementType) {
 		return fmt.Errorf("unmarshalList for %s parent type %T, has bad field type %v", listElementType, parent, listElementType)
 	}
+	isUpdate := (util.IsTypeMap(t) && isAllowUpdateInListMap(opts))
+	isListUpdate := isUpdate
+	mapV := reflect.ValueOf(parent)
+
+	isKeyHasPtr := false
+	keyCnt := 0
+	if isListUpdate {
+		keyCnt = mapV.Len()
+		if keyCnt == 0 {
+			isListUpdate = false
+		} else {
+			itr := mapV.MapRange()
+			itr.Next()
+			isKeyHasPtr = isKeyHasStructPtr(itr.Key())
+		}
+	}
 
 	// Iterate over JSON list. Each JSON list element is a map with the field
 	// name as the key. The JSON values must be unmarshaled and inserted into
@@ -325,22 +375,75 @@ func unmarshalList(schema *yang.Entry, parent interface{}, jsonList interface{},
 	// types respectively.
 	// For a keyed list, the value(s) of the key are derived from the key fields
 	// in the new list element.
+	keyMap := make(map[string]bool)
 	for _, le := range jl {
 		var err error
 		jt := le.(map[string]interface{})
 		newVal := reflect.New(listElementType.Elem())
 		util.DbgPrint("creating a new list element val of type %v", newVal.Type())
-		if err := unmarshalStruct(schema, newVal.Interface(), jt, enc, opts...); err != nil {
-			return err
+		keyStr := ""
+		if isUpdate {
+			keyStr, err = unmarshalKeyFieldsInStruct(schema, parent, newVal.Interface(), jt, enc, opts...)
+			if err != nil {
+				log.Warning("Error in unmarshaling key fields: ", err, " and the structure type: ", newVal.Type())
+				pretty.Print(newVal.Interface())
+				pretty.Print(jt)
+				log.Info("Error in unmarshaling: schema key: ", schema.Key, " - parent type : ", reflect.TypeOf(parent), " - key type", reflect.TypeOf(parent).Key())
+				return err
+			} else if log.V(6) {
+				log.Info("unmarshalKeyFieldsInStruct: key in string format: ", keyStr)
+			}
+			if keyCnt == 0 && !keyMap[keyStr] {
+				isListUpdate = false
+			}
+		}
+		if !isListUpdate {
+			if err := unmarshalStruct(schema, newVal.Interface(), jt, enc, opts...); err != nil {
+				return err
+			}
 		}
-
 		switch {
 		case util.IsTypeMap(t):
 			newKey, err := makeKeyForInsert(schema, parent, newVal)
 			if err != nil {
 				return err
 			}
-			err = util.InsertIntoMap(parent, newKey.Interface(), newVal.Interface())
+			isKeyExist := false
+			if isListUpdate {
+				if isKeyHasPtr {
+					iter := mapV.MapRange()
+					for iter.Next() {
+						if cmp.Equal(iter.Key().Interface(), newKey.Interface()) {
+							newVal = iter.Value()
+							isKeyExist = true
+							if !keyMap[keyStr] {
+								keyCnt--
+								keyMap[keyStr] = true
+							}
+							break
+						}
+					}
+				} else if listKV := mapV.MapIndex(reflect.ValueOf(newKey.Interface())); listKV.IsValid() {
+					if log.V(6) {
+						log.Info("Unmarshaling: key's type: ", newKey.Type(), " with value: ", newKey, " already exist in the map for the structure: ", listKV.Type())
+						log.Info("Unmarshaling: schema.Key: ", schema.Key, " - parent type : ", reflect.TypeOf(parent), " - key type", reflect.TypeOf(parent).Key())
+						pretty.Print(listKV.Interface())
+						pretty.Print(jt)
+					}
+					newVal = listKV
+					isKeyExist = true
+					if !keyMap[keyStr] {
+						keyCnt--
+						keyMap[keyStr] = true
+					}
+				}
+				if err := unmarshalStruct(schema, newVal.Interface(), jt, enc, opts...); err != nil {
+					return err
+				}
+			}
+			if !isKeyExist {
+				err = util.InsertIntoMap(parent, newKey.Interface(), newVal.Interface())
+			}
 		case util.IsTypeSlicePtr(t):
 			err = util.InsertIntoSlice(parent, newVal.Interface())
 		default:
@@ -350,7 +453,9 @@ func unmarshalList(schema *yang.Entry, parent interface{}, jsonList interface{},
 			return err
 		}
 	}
-	util.DbgPrint("list after unmarshal:\n%s\n", pretty.Sprint(parent))
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("list after unmarshal:\n%s\n", pretty.Sprint(parent))
+	}
 
 	return nil
 }
@@ -394,11 +499,91 @@ func makeValForInsert(schema *yang.Entry, parent interface{}, keys map[string]st
 		if util.IsValuePtr(fv) {
 			ft = ft.Elem()
 		}
-
-		nv, err := StringToType(ft, fieldVal)
+		sf, ok := val.Elem().Type().FieldByName(fn)
+		if ok == false {
+			return fmt.Errorf("Field %s not present in the struct %s", fn, val.Elem())
+		}
+		cschema, err := util.ChildSchema(schema, sf)
 		if err != nil {
 			return err
 		}
+		keyLeafKind := cschema.Type.Kind
+		if keyLeafKind == yang.Yleafref {
+			lrfschema, err := util.ResolveIfLeafRef(cschema)
+			if err != nil {
+				return err
+			}
+			keyLeafKind = lrfschema.Type.Kind
+		}
+
+		var nv reflect.Value
+		if keyLeafKind == yang.Yunion && strings.HasSuffix(ft.Name(), "_Union") {
+			sks, err := getUnionKindsNotEnums(cschema)
+			if err != nil {
+				return err
+			}
+			for _, sk := range sks {
+				gv, err := StringToType(reflect.TypeOf(yangBuiltinTypeToGoType(sk)), fieldVal)
+				if err == nil {
+					mn := "To_" + ft.Name()
+					mapMethod := val.MethodByName(mn)
+					if !mapMethod.IsValid() {
+						return fmt.Errorf("%s does not have a %s function", val, mn)
+					}
+					ec := mapMethod.Call([]reflect.Value{gv})
+					if len(ec) != 2 {
+						return fmt.Errorf("%s %s function returns %d params", ft.Name(), mn, len(ec))
+					}
+					ei := ec[0].Interface()
+					ee := ec[1].Interface()
+					if ee != nil {
+						return fmt.Errorf("unmarshaled %v type %T does not have a union type: %v", fieldVal, fieldVal, ee)
+					}
+					nv = reflect.ValueOf(ei)
+					break
+				}
+			}
+
+			if nv.IsValid() == false {
+				ets, err := schemaToEnumTypes(cschema, val.Type())
+				if err != nil {
+					return err
+				}
+				for _, et := range ets {
+					ev, err := castToEnumValue(et, fieldVal)
+					if err != nil {
+						return err
+					}
+					if ev != nil {
+						mn := "To_" + ft.Name()
+						mapMethod := val.MethodByName(mn)
+						if !mapMethod.IsValid() {
+							return fmt.Errorf("%s does not have a %s function", val, mn)
+						}
+						ec := mapMethod.Call([]reflect.Value{reflect.ValueOf(ev)})
+						if len(ec) != 2 {
+							return fmt.Errorf("%s %s function returns %d params", ft.Name(), mn, len(ec))
+						}
+						ei := ec[0].Interface()
+						ee := ec[1].Interface()
+						if ee != nil {
+							return fmt.Errorf("unmarshaled %v type %T does not have a union type: %v", fieldVal, fieldVal, ee)
+						}
+						nv = reflect.ValueOf(ei)
+						break
+					}
+					fmt.Errorf("could not unmarshal %v into enum type: %s\n", fieldVal, err)
+				}
+				if nv.IsValid() == false {
+					return fmt.Errorf("could not create the value type for the field name %s  with the value %s", fn, fieldVal)
+				}
+			}
+		} else {
+			nv, err = StringToType(ft, fieldVal)
+			if err != nil {
+				return err
+			}
+		}
 		return util.InsertIntoStruct(val.Interface(), fn, nv.Interface())
 	}
 
@@ -468,6 +653,8 @@ func makeKeyForInsert(schema *yang.Entry, parentMap interface{}, newVal reflect.
 	kv, err := getKeyValue(newVal.Elem(), schema.Key)
 	if err != nil {
 		return reflect.ValueOf(nil), err
+	} else if kv == nil {
+		return reflect.ValueOf(nil), fmt.Errorf("List key leaf node %v is not present in the payload", schema.Key)
 	}
 	util.DbgPrint("key value is %v.", kv)
 
@@ -494,6 +681,9 @@ func insertAndGetKey(schema *yang.Entry, root interface{}, keys map[string]strin
 	}
 
 	// TODO(yusufsn): When the key is a leafref, its target should be filled out.
+	if len(keys) == 0 {
+		return nil, nil
+	}
 	mapVal, err := makeValForInsert(schema, root, keys)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create map value for insert, root %T, keys %v: %v", root, keys, err)
@@ -524,7 +714,16 @@ func unmarshalContainerWithListSchema(schema *yang.Entry, parent interface{}, va
 	}
 	// Create a container equivalent of the list, which is just the list
 	// with ListAttrs unset.
+	// Since we've patched a mutex into the Entry struct we need special handling
+	// when making this copy.  We don't want to copy the mutex while it is locked
+	// by another goroutine, doing so would leave newSchema's copy of the mutex
+	// also locked but it would never be unlocked making it a deadlock risk.
+	// To avoid this, we lock the original mutex, make the copy, then unlock both
+	// the original and copy mutex.
+	schema.ChildSchemaMutex.Lock()
 	newSchema := *schema
+	schema.ChildSchemaMutex.Unlock()
+	newSchema.ChildSchemaMutex.Unlock()
 	newSchema.ListAttr = nil
 	return Unmarshal(&newSchema, parent, value, opts...)
 }
@@ -557,3 +756,43 @@ func getKeyValue(structVal reflect.Value, key string) (interface{}, error) {
 
 	return nil, fmt.Errorf("could not find key field %s in struct type %s", key, structVal.Type())
 }
+
+// UnmarshalListKey creates the key and its value (ygot struct) and insert into the map return the created ygot struct
+// if the key is not already present in the map
+func UnmarshalListKey(schema *yang.Entry, root interface{}, keys map[string]string) (interface{}, error) {
+	switch {
+	case schema.Key == "":
+		return nil, fmt.Errorf("unkeyed list can't be traversed, type %T, keys %v", root, keys)
+	case !util.IsValueMap(reflect.ValueOf(root)):
+		return nil, fmt.Errorf("root has type %T, want map", root)
+	}
+	if len(keys) == 0 {
+		return nil, nil
+	}
+
+	mapVal, err := makeValForInsert(schema, root, keys)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create map value for insert, root %T, keys %v: %v", root, keys, err)
+	}
+
+	mapKey, err := makeKeyForInsert(schema, root, mapVal)
+	if err != nil {
+		return nil, err
+	}
+
+	mapV := reflect.ValueOf(root)
+
+	if listKV := mapV.MapIndex(mapKey); listKV.IsValid() {
+		if log.V(5) {
+			log.Info("Unmarshaling: key's type: ", mapKey.Type(), " with value: ", mapKey, " already exist in the map for the structure: ", listKV.Type())
+		}
+		return listKV.Interface(), nil
+	}
+
+	err = util.InsertIntoMap(root, mapKey.Interface(), mapVal.Interface())
+	if err != nil {
+		return nil, fmt.Errorf("failed to insert into map %T, keys %v: %v", root, keys, err)
+	}
+
+	return mapVal.Interface(), nil
+}
diff --git a/ytypes/node.go b/ytypes/node.go
index bad8474..e38c0f9 100644
--- a/ytypes/node.go
+++ b/ytypes/node.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -24,6 +27,8 @@ import (
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
 
+	"strings"
+
 	gpb "github.com/openconfig/gnmi/proto/gnmi"
 )
 
@@ -53,6 +58,9 @@ type retrieveNodeArgs struct {
 	// specifically to deal with uint values being streamed as positive int
 	// values.
 	tolerateJSONInconsistenciesForVal bool
+	// if retListMap is set to true then target list map will be retrieved
+	// if the target node of the path is list without keys
+	retListMap bool
 }
 
 // retrieveNode is an internal function that retrieves the node specified by
@@ -140,6 +148,16 @@ func retrieveNodeContainer(schema *yang.Entry, root interface{}, path *gpb.Path,
 				if err := util.InitializeStructField(root, ft.Name); err != nil {
 					return nil, status.Errorf(codes.Unknown, "failed to initialize struct field %s in %T, child schema %v, path %v", ft.Name, root, cschema, path)
 				}
+
+				if cschema.IsLeaf() || cschema.IsLeafList() {
+					if len(path.Elem) == 1 && len(path.Elem[0].Key) == 1 {
+						var vals []string
+						vals = append(vals, path.Elem[0].Key[path.Elem[0].Name])
+						if args.val, err = ygot.EncodeTypedValue(vals, gpb.Encoding_JSON_IETF); err != nil {
+							return nil, status.Errorf(codes.Unknown, "failed to get the typed value '%v' for leaf/leaf-list => %s in %T ; because of %v", vals, ft.Name, root, err)
+						}
+					}
+				}
 			}
 
 			// If delete is specified, and the path is exhausted, then we set the
@@ -202,6 +220,11 @@ func retrieveNodeList(schema *yang.Entry, root interface{}, path, traversedPath
 		return nil, status.Errorf(codes.InvalidArgument, "root has type %T, expect map", root)
 	}
 
+	if len(path.GetElem()[0].GetKey()) == 0 && args.retListMap {
+		// returning list map, since there is no keys present in the path
+		return []*TreeNode{{Path: traversedPath, Schema: schema, Data: root}}, nil
+	}
+
 	var matches []*TreeNode
 
 	listKeyT := rv.Type().Key()
@@ -243,6 +266,17 @@ func retrieveNodeList(schema *yang.Entry, root interface{}, path, traversedPath
 			if err != nil {
 				return nil, status.Errorf(codes.InvalidArgument, "failed to convert %v to a string, path %v: %v", kv, path, err)
 			}
+
+			if strings.Contains(keyAsString, "\\") {
+				keyPath, err := ygot.StringToStructuredPath(schema.Name + "[" + schema.Key + "=" + keyAsString + "]")
+				if err != nil {
+					return nil, status.Errorf(codes.InvalidArgument, "failed to convert %v to a string, path %v: %v", kv, path, err)
+				}
+				if len(keyPath.Elem) == 1 {
+					keyAsString = keyPath.Elem[0].Key[schema.Key]
+				}
+			}
+
 			if keyAsString == pathKey {
 				remainingPath := util.PopGNMIPath(path)
 				if args.delete && len(remainingPath.GetElem()) == 0 {
@@ -287,6 +321,15 @@ func retrieveNodeList(schema *yang.Entry, root interface{}, path, traversedPath
 			if err != nil {
 				return nil, status.Errorf(codes.Unknown, "failed to convert the field value to string, field %v: %v", fieldName, err)
 			}
+			if strings.Contains(keyAsString, "\\") {
+				keyPath, err := ygot.StringToStructuredPath(schema.Name + "[" + schemaKey + "=" + keyAsString + "]")
+				if err != nil {
+					return nil, status.Errorf(codes.Unknown, "failed to convert the field value to string, field %v: %v", fieldName, err)
+				}
+				if len(keyPath.Elem) == 1 {
+					keyAsString = keyPath.Elem[0].Key[schemaKey]
+				}
+			}
 			if !(args.handleWildcards && pathKey == "*") && pathKey != keyAsString {
 				match = false
 				break
@@ -319,6 +362,11 @@ func retrieveNodeList(schema *yang.Entry, root interface{}, path, traversedPath
 		if err != nil {
 			return nil, err
 		}
+
+		if key == nil {
+			return []*TreeNode{{Path: traversedPath, Schema: schema, Data: root}}, nil
+		}
+
 		nodes, err := retrieveNode(schema, rv.MapIndex(reflect.ValueOf(key)).Interface(), util.PopGNMIPath(path), appendElem(traversedPath, path.GetElem()[0]), args)
 		if err != nil {
 			return nil, err
@@ -345,6 +393,18 @@ func GetOrCreateNode(schema *yang.Entry, root interface{}, path *gpb.Path) (inte
 	return nodes[0].Data, nodes[0].Schema, nil
 }
 
+// GetOrCreateTargetNode function is similar to GetOrCreateNode function, but it returns the list map object
+// if the target node of the path is list without keys
+func GetOrCreateTargetNode(schema *yang.Entry, root interface{}, path *gpb.Path) (interface{}, *yang.Entry, error) {
+	nodes, err := retrieveNode(schema, root, path, nil, retrieveNodeArgs{modifyRoot: true, retListMap: true})
+	if err != nil {
+		return nil, nil, err
+	}
+
+	// There must be a result as this function initializes nodes along the supplied path.
+	return nodes[0].Data, nodes[0].Schema, nil
+}
+
 // TreeNode wraps an individual entry within a YANG data tree to return to a caller.
 type TreeNode struct {
 	// Schema is the schema entry for the data tree node, specified as a goyang Entry struct.
diff --git a/ytypes/string_type.go b/ytypes/string_type.go
index 4ae91e2..f91bd74 100644
--- a/ytypes/string_type.go
+++ b/ytypes/string_type.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -19,10 +22,14 @@ import (
 	"fmt"
 	"regexp"
 	"unicode/utf8"
+  "sync"
 
 	"github.com/openconfig/goyang/pkg/yang"
 )
 
+var regexpCache map[string]*regexp.Regexp = make(map[string]*regexp.Regexp)
+var regexpMutex sync.RWMutex = sync.RWMutex{}
+
 // Refer to: https://tools.ietf.org/html/rfc6020#section-9.4.
 
 // validateString validates value, which must be a Go string type, against the
@@ -48,10 +55,23 @@ func validateString(schema *yang.Entry, value interface{}) error {
 
 	// Check that the value satisfies any regex patterns.
 	for _, p := range schema.Type.Pattern {
-		r, err := regexp.Compile(fixYangRegexp(p))
-		if err != nil {
-			return err
+		var r *regexp.Regexp
+		regexpMutex.RLock()
+		if val, ok := regexpCache[p]; ok {
+			regexpMutex.RUnlock()
+			r = val
+		} else {
+			regexpMutex.RUnlock()
+			var err error
+			r, err = regexp.Compile(fixYangRegexp(p))
+			if err != nil {
+				return err
+			}
+			regexpMutex.Lock()
+			regexpCache[p] = r
+			regexpMutex.Unlock()	
 		}
+		
 		// fixYangRegexp adds ^(...)$ around the pattern - the result is
 		// equivalent to a full match of whole string.
 		if !r.MatchString(stringVal) {
@@ -105,13 +125,33 @@ func validateStringSchema(schema *yang.Entry) error {
 		return fmt.Errorf("string schema %s has wrong type %v", schema.Name, schema.Type.Kind)
 	}
 
+	if schema.IsSchemaValidated {
+		return nil
+	}
+	
+	var err error
+	
 	for _, p := range schema.Type.Pattern {
-		if _, err := regexp.Compile(fixYangRegexp(p)); err != nil {
-			return fmt.Errorf("error generating regexp %s %v for schema %s", p, err, schema.Name)
-		}
+	  regexpMutex.RLock()
+		_, ok := regexpCache[p]
+		regexpMutex.RUnlock()
+		if (ok == false) {
+			var r *regexp.Regexp
+			if r, err = regexp.Compile(fixYangRegexp(p)); err != nil {
+				return fmt.Errorf("error generating regexp %s %v for schema %s", p, err, schema.Name)
+			} else {
+			  regexpMutex.Lock()
+				regexpCache[p] = r
+				regexpMutex.Unlock()
+			}
+		}		
 	}
 
-	return validateLengthSchema(schema)
+	if err = validateLengthSchema(schema); err == nil {
+		schema.IsSchemaValidated = true
+	}
+	
+	return err 
 }
 
 // fixYangRegexp takes a pattern regular expression from a YANG module and
diff --git a/ytypes/unmarshal.go b/ytypes/unmarshal.go
index 864562f..2eea6d2 100644
--- a/ytypes/unmarshal.go
+++ b/ytypes/unmarshal.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -39,6 +42,13 @@ type IgnoreExtraFields struct{}
 // IsUnmarshalOpt marks IgnoreExtraFields as a valid UnmarshalOpt.
 func (*IgnoreExtraFields) IsUnmarshalOpt() {}
 
+// AllowUpdateInListMap is an unmarshal option to update the key and value
+// if it is present in the list map already
+type AllowUpdateInListMap struct{}
+
+// IsUnmarshalOpt marks AllowUpdateInListMap as a valid UnmarshalOpt.
+func (*AllowUpdateInListMap) IsUnmarshalOpt() {}
+
 // Unmarshal recursively unmarshals JSON data tree in value into the given
 // parent, using the given schema. Any values already in the parent that are
 // not present in value are preserved. If provided schema is a leaf or leaf
@@ -81,7 +91,10 @@ func unmarshalGeneric(schema *yang.Entry, parent interface{}, value interface{},
 	if schema == nil {
 		return fmt.Errorf("nil schema for parent type %T, value %v (%T)", parent, value, value)
 	}
-	util.DbgPrint("Unmarshal value %v, type %T, into parent type %T, schema name %s", util.ValueStrDebug(value), value, parent, schema.Name)
+	
+	if (util.IsDebugLibraryEnabled()) {
+		util.DbgPrint("Unmarshal value %v, type %T, into parent type %T, schema name %s", util.ValueStrDebug(value), value, parent, schema.Name)	
+	}
 
 	if enc == GNMIEncoding && !(schema.IsLeaf() || schema.IsLeafList()) {
 		return errors.New("unmarshalling a non leaf node isn't supported in GNMIEncoding mode")
@@ -112,3 +125,14 @@ func hasIgnoreExtraFields(opts []UnmarshalOpt) bool {
 	}
 	return false
 }
+
+// isAllowUpdateInListMap determines whether the supplied slice of UnmarshalOpts contains
+// the AllowUpdateInListMap option.
+func isAllowUpdateInListMap(opts []UnmarshalOpt) bool {
+	for _, o := range opts {
+		if _, ok := o.(*AllowUpdateInListMap); ok {
+			return true
+		}
+	}
+	return false
+}
diff --git a/ytypes/validate.go b/ytypes/validate.go
index a99f449..1ee0c17 100644
--- a/ytypes/validate.go
+++ b/ytypes/validate.go
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ytypes
 
 import (
@@ -74,7 +77,7 @@ func Validate(schema *yang.Entry, value interface{}, opts ...ygot.ValidationOpti
 		errs = ValidateLeafRefData(schema, value, leafrefOpt)
 	}
 
-	util.DbgPrint("Validate with value %v, type %T, schema name %s", util.ValueStr(value), value, schema.Name)
+	util.DbgPrint("Validate with value %v, type %T, schema name %s", util.ValueStrDebug(value), value, schema.Name)
 
 	switch {
 	case schema.IsLeaf():
